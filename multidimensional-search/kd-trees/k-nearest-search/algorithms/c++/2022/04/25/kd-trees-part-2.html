<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>K-d trees part 2 | qubit-computing</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="K-d trees part 2" />
<meta name="author" content="Alexandros Giavaras" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Implement a k-d tree in C++" />
<meta property="og:description" content="Implement a k-d tree in C++" />
<link rel="canonical" href="https://pockerman.github.io/qubit_opus/multidimensional-search/kd-trees/k-nearest-search/algorithms/c++/2022/04/25/kd-trees-part-2.html" />
<meta property="og:url" content="https://pockerman.github.io/qubit_opus/multidimensional-search/kd-trees/k-nearest-search/algorithms/c++/2022/04/25/kd-trees-part-2.html" />
<meta property="og:site_name" content="qubit-computing" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-04-25T00:00:00-05:00" />
<script type="application/ld+json">
{"url":"https://pockerman.github.io/qubit_opus/multidimensional-search/kd-trees/k-nearest-search/algorithms/c++/2022/04/25/kd-trees-part-2.html","@type":"BlogPosting","headline":"K-d trees part 2","dateModified":"2022-04-25T00:00:00-05:00","datePublished":"2022-04-25T00:00:00-05:00","author":{"@type":"Person","name":"Alexandros Giavaras"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://pockerman.github.io/qubit_opus/multidimensional-search/kd-trees/k-nearest-search/algorithms/c++/2022/04/25/kd-trees-part-2.html"},"description":"Implement a k-d tree in C++","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/qubit_opus/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://pockerman.github.io/qubit_opus/feed.xml" title="qubit-computing" /><link rel="shortcut icon" type="image/x-icon" href="/qubit_opus/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" /><script src="https://hypothes.is/embed.js" async></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/qubit_opus/">qubit-computing</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/qubit_opus/about/">About Me</a><a class="page-link" href="/qubit_opus/projects/">Projects</a><a class="page-link" href="/qubit_opus/search/">Search</a><a class="page-link" href="/qubit_opus/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">K-d trees part 2</h1><p class="page-description">Implement a k-d tree in C++</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-04-25T00:00:00-05:00" itemprop="datePublished">
        Apr 25, 2022
      </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Alexandros Giavaras</span></span>
       • <span class="read-time" title="Estimated read time">
    
    
      5 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/qubit_opus/categories/#multidimensional-search">multidimensional-search</a>
        &nbsp;
      
        <a class="category-tags-link" href="/qubit_opus/categories/#kd-trees">kd-trees</a>
        &nbsp;
      
        <a class="category-tags-link" href="/qubit_opus/categories/#k-nearest-search">k-nearest-search</a>
        &nbsp;
      
        <a class="category-tags-link" href="/qubit_opus/categories/#algorithms">algorithms</a>
        &nbsp;
      
        <a class="category-tags-link" href="/qubit_opus/categories/#c++">c++</a>
        
      
      </p>
    

    
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#Note">Note </a></li>
<li class="toc-entry toc-h2"><a href="#Overview">Overview </a></li>
<li class="toc-entry toc-h2"><a href="#K-d-trees-part-2">K-d trees part 2 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#Building-the-tree">Building the tree </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#References">References </a></li>
</ul><!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2022-04-25-kd-trees-part-2.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Note">
<a class="anchor" href="#Note" aria-hidden="true"><span class="octicon octicon-link"></span></a>Note<a class="anchor-link" href="#Note"> </a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><strong>Under development</strong> :) :) :)</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Overview">
<a class="anchor" href="#Overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview<a class="anchor-link" href="#Overview"> </a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In a previous post, we looked into what k-d trees are. In this post we want to go deeper into this view and attempt to implement a k-d tree in C++. The final code can be found <a href="https://github.com/pockerman/cubeai/blob/master/include/cubeai/data_structs/kd_tree.h">here</a>. Furthermore, we will follow the implementation from the excellent book of Marcello La Rocca <a href="https://www.manning.com/books/advanced-algorithms-and-data-structures">Advanced algorithms and data structures</a> by Manning Publications.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="K-d-trees-part-2">
<a class="anchor" href="#K-d-trees-part-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>K-d trees part 2<a class="anchor-link" href="#K-d-trees-part-2"> </a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Before starting implementing a k-d tree let's recall that this a binary search tree i.e. a hierarchical data structure. Specifically, a  k-d tree is a space partitioning data structure for organizing points in a k-dimensional space [1]. In a k-d tree every node in the tree represents a k-dimensional point [2]. Furthermore, we will assume that the coordinates of k-dimensional vector can be compared with each other.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Following [2], here is the exposed API:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">

<pre><code>template&lt;typename NodeType&gt;
class KDTree
{
public:

 typedef NodeType node_type;
 typedef typename node_type::data_type data_type;

 KDTree(uint_t k);

 template&lt;typename Iterator, typename SimilarityPolicy, typename ComparisonPolicy&gt;
 KDTree(uint_t k, Iterator begin, Iterator end, 
        const SimilarityPolicy&amp; sim_policy, 
        const ComparisonPolicy&amp; comp_policy);

 bool empty()const noexcept;
 uint_t size()const noexcept;
 uint_t dim()const noexcept;

 template&lt;typename ComparisonPolicy&gt;
 std::shared_ptr&lt;node_type&gt;
 search(const data_type&amp; data, const ComparisonPolicy&amp; comp_policy)const;

 template&lt;typename Iterator, typename SimilarityPolicy, typename ComparisonPolicy&gt;
 void build(Iterator begin, Iterator end,
             const SimilarityPolicy&amp; sim_policy, 
             const ComparisonPolicy&amp; comp_policy);

 template&lt;typename ComparisonPolicy&gt;
 std::shared_ptr&lt;node_type&gt;
 insert(const data_type&amp; data, const ComparisonPolicy&amp; comp_policy);

 template&lt;typename ComparisonPolicy&gt;
 std::vector&lt;std::pair&lt;typename ComparisonPolicy::value_type, typename NodeType::data_type&gt;&gt;
 nearest_search(const data_type&amp; data, uint_t n, const ComparisonPolicy&amp; calculator)const;

};</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The class above accepts the tree node as a generic parameter that exposes the type of the data to be stored. In this perspective, the <code>KDTree</code> is a homogeneous container.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>According to the exposed API we can construct a k-d tree in two ways; by specifying the size of the space or by passing a range of data to be stored in the tree. The first construct actually creates an empty tree. We can populate this tree by calling either <code>insert</code> or preferably <code>build</code>. We will explain below why this is the preferred method.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can see that the exposed API does not have a <code>remove</code> or <code>delete</code> method. Typically, a k-d tree is constructed as remains as is. Furthermore, removing a node may result in an unbalanced tree which implies that the fast look up will not hold any more. Although it is possible  to re-balance the tree see e.g. [2], we won't pursue this path here. So let's concentrate on the rest of the methods. Perhaps the most important of which is the <code>build</code> method.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In our implementation we distinguish between similarity and comparison. A similarity metric, or policy, is used in order to decide whether two points are similar or close enough in the given metric. A comparison policy is used in order to compare coordinates of points. Thus, we use the similarity policy to search in the tree. And we use the comparison policy whenever strict comparison of point coordinates is needed.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Building-the-tree">
<a class="anchor" href="#Building-the-tree" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building the tree<a class="anchor-link" href="#Building-the-tree"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The <code>build</code> function accepts a range of iterators pointing to the data, a similarity policy and a comparison policy. It delegates all its to the  <code>call_</code> function; a private to the outside world class that implements the nuts and bolds of building the tree. The <code>call_</code> function definition is shown below</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">

<pre><code>template&lt;typename NodeType&gt;
template&lt;typename Iterator, typename SimilarityPolicy, 
         typename ComparisonPolicy&gt;
void
KDTree&lt;NodeType&gt;::create_(Iterator begin, Iterator end, 
                          uint_t level, 
                          const SimilarityPolicy&amp; sim_policy, 
                          const ComparisonPolicy&amp; comp_policy){


    auto n_points = std::distance(begin, end);

    // nothing to do if no points
    // are given
    if(n_points == 0){
        return ;
    }

    if(n_points == 1){

        auto data = *begin;

        // create the root
        root_ = std::make_shared&lt;NodeType&gt;(level, data, nullptr, nullptr);
        ++n_nodes_;
        return;
    }

    // otherwise partition the range
    auto [median, left, right] = detail::partiion_on_median(begin, end, level, k_, comp_policy);

    // create root
    root_ = std::make_shared&lt;NodeType&gt;(level, median, nullptr, nullptr);
    ++n_nodes_;

    // create left and right subtrees
    auto left_tree = do_create_(left.first, left.second, level + 1, sim_policy, comp_policy);

    // create left and right subtrees
    auto right_tree = do_create_(right.first, right.second, level + 1, sim_policy, comp_policy);

    root_-&gt;left = left_tree;
    root_-&gt;right = right_tree;
}</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The implementation above is fairly straightforward. However, let's go over a few details. The <code>detail::partiion_on_median</code> accepts a range of points the current tree <code>level</code> and the <code>comp_policy</code> and returns the median point at this <code>level</code> and the data that is left and right to the calculated median.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">

<pre><code>template&lt;typename Iterator, typename ComparisonPolicy&gt;
std::tuple&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type,
           std::pair&lt;Iterator, Iterator&gt;,
           std::pair&lt;Iterator, Iterator&gt;&gt;
partiion_on_median(Iterator begin, Iterator end, 
                   uint_t level, uint_t k, 
                   const ComparisonPolicy&amp; comp_policy){

    ...

    // the median index
    auto median_idx = n_points % 2 == 0 ? (n_points + 1) / 2 : n_points / 2;

    // how to compare the data at the given
    // level. We use the level % k operation to decide
    // which coordinate to use
    auto compare = [&amp;](const value_type&amp; v1, const value_type&amp; v2){
        auto idx = level % k;
        return comp_policy(v1, v2, idx); //v1[idx] &lt; v2[idx];
    };


    // rearrange the elements. Do partial sorting
    // 
    std::nth_element(begin, begin + median_idx, end , compare);

    // get the data corresponding to the median
    auto median = *(begin + median_idx);

    // create the left are right sub-trees
    auto left = std::make_pair&lt;Iterator,   Iterator&gt;(std::forward&lt;Iterator&gt;(begin), begin + median_idx);
    auto right = std::make_pair&lt;Iterator,   Iterator&gt;(begin + median_idx + 1, std::forward&lt;Iterator&gt;(end));
    return std::make_tuple(median, left, right);

}</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The implementation above uses <a href="https://en.cppreference.com/w/cpp/algorithm/nth_element">std::nth_element</a> to partially sort the elements. According to the documentation:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>_<code>nth_element</code> is a partial sorting algorithm that rearranges elements in <code>[first, last)</code> such that_</p>
<ul>
<li><em>The element pointed at by nth is changed to whatever element would occur in that position if <code>[first, last)</code> were sorted.</em></li>
<li><em>All of the elements before this new nth element are less than or equal to the elements after the new nth element.</em></li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We then recursively build the tree using <code>do_create_</code></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="References">
<a class="anchor" href="#References" aria-hidden="true"><span class="octicon octicon-link"></span></a>References<a class="anchor-link" href="#References"> </a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ol>
<li>
<a href="https://en.wikipedia.org/wiki/K-d_tree">k-d tree</a>.</li>
<li>Marcello La Rocca, <em>Advanced algorithms and data structures</em>, Manning Publications.</li>
</ol>

</div>
</div>
</div>
</div>



  </div><a class="u-url" href="/qubit_opus/multidimensional-search/kd-trees/k-nearest-search/algorithms/c++/2022/04/25/kd-trees-part-2.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/qubit_opus/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/qubit_opus/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/qubit_opus/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Computing is fun (most of the times...)</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/pockerman" target="_blank" title="pockerman"><svg class="svg-icon grey"><use xlink:href="/qubit_opus/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
